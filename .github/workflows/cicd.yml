# .github/workflows/cicd.yml
name: CI/CD yoga-bot-py

on:
  push:
    branches: [ "main" ]

concurrency:
  group: cicd-yoga-bot-py
  cancel-in-progress: true

env:
  IMAGE_NAME: yogadaily-bot
  DEPLOYMENT_NAME: yogadaily-bot
  CONTAINER_NAME: yogadaily-bot

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Compute image tags
        id: meta
        run: |
          SHA="${GITHUB_SHA::7}"
          TS="$(date -u +%Y%m%d%H%M%S)"
          echo "TAG=${TS}-${SHA}" >> $GITHUB_OUTPUT
          REG="${{ secrets.REGISTRY }}"
          REPO="${{ secrets.REGISTRY_REPO }}"
          if [ -n "$REPO" ]; then
            IMAGE="$REG/$REPO/${{ env.IMAGE_NAME }}"
          else
            IMAGE="$REG/${{ env.IMAGE_NAME }}"
          fi
          echo "IMAGE=$IMAGE" >> $GITHUB_OUTPUT

      - name: Compute cache key from requirements.txt
        id: cache_key
        run: |
          REQ_HASH=$(sha256sum requirements.txt | cut -d' ' -f1 | cut -c1-12)
          echo "REQ_HASH=$REQ_HASH" >> $GITHUB_OUTPUT
      
      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./deploy/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ steps.meta.outputs.IMAGE }}:${{ steps.meta.outputs.TAG }}
            ${{ steps.meta.outputs.IMAGE }}:latest
          build-args: |
            CACHE_BUSTER=${{ steps.cache_key.outputs.REQ_HASH }}
          cache-from: type=registry,ref=${{ steps.meta.outputs.IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ steps.meta.outputs.IMAGE }}:buildcache,mode=max

      - name: Export latest image ref
        run: echo "${{ steps.meta.outputs.IMAGE }}:latest" > image.txt

      - name: Upload artifact (image ref)
        uses: actions/upload-artifact@v4
        with:
          name: image-ref
          path: image.txt

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Download image ref
        uses: actions/download-artifact@v4
        with:
          name: image-ref
          path: .

      - name: Read image var
        id: img
        run: |
          echo "IMAGE=$(cat image.txt)" >> $GITHUB_OUTPUT

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Write kubeconfig
        run: |
          mkdir -p ~/.kube
          printf "%s" "${{ secrets.KUBE_CONFIG }}" > ~/.kube/config

      - name: Apply ConfigMap
        run: |
          kubectl -n "${{ secrets.K8S_NAMESPACE }}" apply -f deploy/k8s/configmap.yaml
          # Deployment не применяем здесь, чтобы не перезаписывать образ, установленный через set image
          # Deployment создается один раз вручную или через отдельный скрипт деплоя

      - name: Set image to :latest
        run: |
          kubectl -n "${{ secrets.K8S_NAMESPACE }}" set image deploy/${{ env.DEPLOYMENT_NAME }} \
            ${{ env.CONTAINER_NAME }}=${{ steps.img.outputs.IMAGE }} --record

      - name: Wait for rollout
        run: |
          kubectl -n "${{ secrets.K8S_NAMESPACE }}" rollout status deploy/${{ env.DEPLOYMENT_NAME }} --timeout=180s
